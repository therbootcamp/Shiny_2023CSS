<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Explorative Datenanalyse      The R Bootcamp @ CSS  " />


<title>Graphiken</title>

<script src="Graphiken_practical_files/header-attrs-2.20/header-attrs.js"></script>
<script src="Graphiken_practical_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Graphiken_practical_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Graphiken_practical_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Graphiken_practical_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Graphiken_practical_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="Graphiken_practical_files/navigation-1.1/tabsets.js"></script>
<link href="Graphiken_practical_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Graphiken_practical_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="practical.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div id="header">



<h1 class="title toc-ignore">Graphiken</h1>
<h4 class="author"><font style='font-style:normal'>Explorative
Datenanalyse</font><br>
<a href='https://therbootcamp.github.io/Shiny_2023CSS/'><i class='fas fa-clock' style='font-size:.9em;' ></i></a>
<a href='https://therbootcamp.github.io'><i class='fas fa-home' style='font-size:.9em;'></i></a>
<a href='mailto:therbootcamp@gmail.com'><i class='fas fa-envelope' style='font-size: .9em;'></i></a>
<a href='https://www.linkedin.com/company/basel-r-bootcamp/'><i class='fab fa-linkedin' style='font-size: .9em;'></i></a>
<a href='https://therbootcamp.github.io'><font style='font-style:normal'>The
R Bootcamp @ CSS</font></a><br>
<img src='https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/by-sa.png' style='height:15px;width:80px'/></h4>

</div>


<p align="center" width="100%">
<img src="image/brushes.jpg" alt="Trulli" style="width:100%"> <br>
<font style="font-size:10px">from
<a href="https://unsplash.com/photos/ouyjDk-KdfY">unsplash.com</a></font>
</p>
<div id="section" class="section level1 tabset">
<h1 class="tabset"></h1>
<div id="information" class="section level2">
<h2>Information</h2>
<p>Dieses Practical besteht aus zwei Teilen.</p>
<ol style="list-style-type: decimal">
<li>Aufgaben: Mit mehreren kleinen Apps wiederholst du zentrale Inhalte
der Präsentation.<br />
</li>
<li>App: Über die Sessions hinweg entwickelst Du die
<a href="https://dirkwulff.shinyapps.io/TheRBootcamp/">InjuryViewer</a>
App</li>
</ol>
<p>Wie viel Zeit du in <em>Aufgaben</em> oder <em>App</em> verbringst
ist dir überlassen. Wir empfehlen aber allen mit wenig Erfahrung mit
Shiny erst einmal in Aufgaben zu schauen. Für die App stellen wir in
einem eigenen Tab die Lösungen zur Verfügungen, so dass du in neue
Themen einsteigen kannst ohne notwendigerweise alle Schritte der
Appentwicklung abgeschlossen zu haben.</p>
<p>Für jede App in Aufgaben erstelle bitte ein <strong>neues
Skript</strong> und speichere es unter dem Namen der
Abschnittsberschrift. Denk dran bei jedem neuen Skript
<code>library(shiny)</code> an den Anfang zu setzen. Falls weitere
Pakete nötig sind, werden sie in der jeweileigen Abschnitten
erwähnt.</p>
<p>Gerade am Anfang stellen wir Code-Templates zur verfügung in denen du
allein die <code>XX</code> durch den richtigen Code bzw. die richtigen
Objekte erstezen musst.</p>
</div>
<div id="aufgaben" class="section level2">
<h2>Aufgaben</h2>
<div id="a---puppies" class="section level3">
<h3>A - Puppies</h3>
<ol style="list-style-type: decimal">
<li>Bauen wir die Puppies App. Die Puppy App rotiert zwischen Bildern
von Welpen rotiert, wenn der Nutzer auf das Bild eines Welpen klickt.
Beginnen wir mit der UI. Baue eine <code>fluidPage</code> UI mit einer
<code>fluidRow</code> und drei <code>column</code>s, die jeweils eine
Breite von <code>4</code> haben.</li>
</ol>
<pre class="r"><code>ui &lt;- XX(
  XX(
    XX(XX),
    XX(XX),
    XX(XX)
  )
)</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>In die mittlere Column setze nun ein <code>titlePanel</code> mit
<code>title = "A Puppy"</code>, einen <code>htmlOutput</code> mit ID
<code>"quelle"</code> für das Anzeigen der Bildquelle, und einen
<code>imageOutput</code> mit ID <code>"bild"</code> für das Anzeigen des
Bildes.</li>
</ol>
<pre class="r"><code>ui &lt;- XX(
  XX(
    XX(XX),
    XX(XX,
       XX(XX),
       XX(XX),
       XX(XX)
       ),
    XX(XX)
  )
)</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Später müssen noch ein paar Änderungen am <code>imageOutput</code>
vornehmen, um Interaktivität herzustellen, zunächst kümmere dich aber
ersteinmal um den <code>server</code>, damit du die App testen kannst.
Kreiere einen <code>server</code> mit zwei Outputs, ein
<code>renderText</code> für die Bildquelle und ein
<code>renderImage</code> für das Bild. Weise die beiden den richtigen
IDs im <code>output</code> zu.</li>
</ol>
<pre class="r"><code>server = function(input, output, session){

  XX$XX = XX()
  XX$XX = XX()
  
  }</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Als nächstes laden den Datensatz <code>puppies</code>, damit wir im
<code>server</code> darauf Bezug nehmen können. Lade vorher das
<code>tidyverse</code> um die Funktion <code>read_csv</code> nutzen zu
können.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX$XX = XX()
  XX$XX = XX()
  
  }</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>Innerhalb des <code>renderText</code> setze nun
<code>HTML(paste("Quelle: &lt;a href=",puppies$url[1],"&gt;Unsplash.com&lt;/a&gt;"))</code>.
Der Code führt dazu, dass für den ersten Eintrag in
<code>puppies$url</code> ein HMTL Link erzeugt wird.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX$XX = XX(XX(XX))
  XX$XX = XX()
  
  }</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>Die Bildquelle ist vorerst fertig, nun zum Bild selber.
<code>renderImage</code> muss eine Liste zur Verfügung gestellt werden,
die den Bildpfad <code>src</code> und andere Bildparameter z.B.
<code>width</code> oder <code>height</code> definiert. Weise
<code>src</code> diesen Code zu
<code>paste0("daten/puppies/",puppies$image[1])</code>, der den Pfad für
das erste Bild in <code>puppies</code> zusammensetzt, und setze
<code>width</code> auf <code>500px</code>, damit das Bild nicht zu gross
angezeigt wird.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX$XX = XX(XX(XX))
  XX$XX = XX(list(
    XX = XX,
    XX = XX
  ))
  
  }</code></pre>
<ol start="7" style="list-style-type: decimal">
<li><p>Jetzt solltest du die App test <code>shinyApp(ui, server)</code>
testen können. Probiere es aus. Wird ein Welpe mit Bildquelle und
Überschrift angezeigt?</p></li>
<li><p>Nun zur Interaktivität. Anstatt dass immmer nur das erste Bild
angezeigt wird, wollen wir, dass die Bilder ausgelöst durch Klicks des
Nutzers durchrotieren. Gehe dafür zuerst in die UI und ergänze innerhalb
des <code>renderImage</code> das Argument <code>click = "weiter"</code>.
Dies generiert einen <code>input$weiter</code>, auf den wir im
<code>server</code> zugreifen können. Später müssen wir
<code>click</code> noch ein wenig anpassen, aber erst einmal gehen wir
zum <code>server</code>.</p></li>
</ol>
<pre class="r"><code>ui &lt;- XX(
  XX(
    XX(XX),
    XX(XX,
       XX(XX),
       XX(XX),
       XX(XX, XX)
       ),
    XX(XX)
  )
)</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>Für die klick-abhängige Rotation der, benötigen wir einen
dynamischen Index anstatt des festes Indexes <code>1</code>. Definiere
dafür wieder mal einen <code>reactiveVal</code> und nenne ihn
<code>index</code>.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX &lt;- XX()
  
  XX$XX = XX(XX(XX))
  XX$XX = XX(list(
    XX = XX,
    XX = XX
  ))
  
  }</code></pre>
<ol start="9" style="list-style-type: decimal">
<li>Jetzt braucht es noch eine Mechanik, die dazu führt das
<code>index</code> sich ändert, wenn der Nutzer auf das Bild klickt.
Definiere dafür einen <code>observeEvent</code> in Abhängigkeit des
Klick-Inputs <code>input$weiter</code>.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX &lt;- XX()
  
  XX(XX, {
    
  })
  
  XX$XX = XX(XX(XX))
  XX$XX = XX(list(
    XX = XX,
    XX = XX
  ))
  
  }</code></pre>
<ol start="10" style="list-style-type: decimal">
<li>Innerhalb des <code>observeEvent</code> setze diesen Code
<code>index((index() %% 5 + 1))</code>, der dazu führt, dass der index
um einen heraufgesetzt wird bis die maximale Anzahl Bilder (fünf)
erreicht, dann springt der Index zurück zur ersten Position.</li>
</ol>
<pre class="r"><code>library(XX)

puppies &lt;- XX(XX)

server = function(input, output, session){

  XX &lt;- XX()
  
  XX(XX, {
    
    XX
    
  })
  
  XX$XX = XX(XX(XX))
  XX$XX = XX(list(
    XX = XX,
    XX = XX
  ))
  
  }</code></pre>
<ol start="10" style="list-style-type: decimal">
<li><p>Als letztes bevor du die App testen kannst, ersetze die beiden
<code>1</code>er im code durch den reaktiven Wert
<code>index</code>.</p></li>
<li><p>Die Klammern nicht vergessen. Dann teste die App. Ändert sich das
Bild, wenn du auf das Bild klickst? Vermutlich nicht, was daran liegt,
dass die Klickbox aktuell kleiner ist als das eigentliche Bild und am
oberen linken Bildrand liegt. Wenn es nicht bereits geklappt hat,
versuche einmal oben links ins Bild zu klicken. Jezt sollte sich das
Bild ändern.</p></li>
<li><p>Um die Klickbox zu vergrössern, müssen wir dem <code>click</code>
Argument im <code>imageOutput</code> explizit die <code>clickOpts</code>
zuweisen darin die <code>id</code> (immmernoch <code>"weiter"</code>)
und auch <code>clip = FALSE</code> zweisen. Letztes sorgt dafür, dass
die Klickbox auf das gesamte Bild ausgedehnt wird.</p></li>
</ol>
<pre class="r"><code>ui &lt;- XX(
  XX(
    XX(XX),
    XX(XX,
       XX(XX),
       XX(XX),
       XX(XX, XX = XX(XX = XX, XX = XX))
       ),
    XX(XX)
  )
)</code></pre>
<ol start="13" style="list-style-type: decimal">
<li>Lasse die App nochmal laufen. Funktioniert nun alles
einwandfrei?</li>
</ol>
</div>
<div id="c---scatter" class="section level3">
<h3>C - Scatter</h3>
<ol style="list-style-type: decimal">
<li>Unten siehst du eine App, die ein Scatterplot der (logarithmierten)
Anzahl der Verletzungen an Körperteilen von jüngeren
(<code>alter &lt; 65</code>) und älteren Personen
(<code>alter &gt;= 65</code>) anzeigt und erlaubt, dass Punkte über die
<code>brush</code> Funktionalität ausgewählt werden. Die ausgewählten
Punkte werden unter dem Scatterplot in einer Tabelle angezeigt. Leider
fehlen der App einige Werte. Es sind einzusetzen die IDs, der
Argumentname <code>brush</code>, und die Funktion
<code>brushedPoints</code>. Kannst du die App zum laufen bringen?</li>
</ol>
<pre class="r"><code>verletzungen_jung_alt = readRDS(&quot;daten/verletzungen.RDS&quot;)  %&gt;% 
    group_by(körperteil, alter = case_when(alter &lt; 65 ~ &quot;jünger&quot;, TRUE ~ &quot;älter&quot;)) %&gt;% 
    summarize(n = log(sum(anzahl))) %&gt;% 
    ungroup() %&gt;% 
    pivot_wider(names_from = alter, values_from = n) %&gt;% 
    na.omit() 


ui = fluidPage(
  fluidRow(
    column(3),
    column(6,
      plotOutput(XX, XX = XX),
      tableOutput(XX)
    ),
    column(3)
    ))

server = function(input, output, session){

  output$XX = renderPlot({
    verletzungen_jung_alt %&gt;% 
      ggplot(aes(x = jünger, y = älter)) +
      geom_point() +
      theme_minimal()
      }, res = 96)

  output$XX &lt;- renderTable({
    XX(verletzungen_jung_alt, input$XX)
  })
      
}


shinyApp(ui, server)</code></pre>
</div>
</div>
<div id="app" class="section level2">
<h2>App</h2>
<ol style="list-style-type: decimal">
<li><p>Jetzt geht es darum eine schematische Visualisierung des
menschlichen Körpers als Teil des UI einzubauen. Als erster Schritt lade
den <code>körper</code>. Printe dann den Datensatz in die Console, um
ein Gefühl für dessen Inhalte zu entwickeln.</p></li>
<li><p>Der <code>körper</code> Datensatz beinhaltet Körperteil Polygone,
die über mehrere Zeilen von x und y Koordinaten definiert sind. Diese
Struktur erlaubt uns den Körper sehr einfach zu plotten. Dabei
behilflich ist die Tatsache, dass die zwei Variablen
<code>körperteil</code> und <code>id</code> als Faktoren formatiert
sind, die die richtige Plotreihenfolge erzeugen. Plotte den Körper mit
folgendem Code. Stelle vorher jedoch sicher, dass <code>tidyverse</code>
und <code>viridis</code> geladen wurden.</p></li>
<li><p>Die Graphik sollte zeigen, dass die Polygone verschiedene
Körperteile oder Körperbereiche abdecken, die zu mit den
Körperteilwerten in unserem Verletzungen Datensatz korrespondieren. Das
erlaubt uns die Visualisierun als Alternative für
<code>selectInput("körperteil")</code> zu verwenden. Vorausgesetzt
natürlich, dass wir aus der Abbildung eine interaktive Abbildung machen.
Bevor wir dazu kommen müssen wir jedoch erst einmal die Abbildung in
unser <code>ui</code> und unseren <code>server</code>einbauen. Setze
dafür zunächst einen <code>plotOutput</code> mit ID <code>körper</code>
in die <code>ui</code> (nicht den <code>server</code>) und zwar anstelle
des <code>selectInput</code>.</p></li>
<li><p>Als nächstes sorge dafür das Plot erscheint indem du das Einlesen
des Körpers in dein App Skript und den Code der Graphic in den
<code>sever</code> bewegst. Denk dran da <code>viridis</code> Paket
neben den bisherigen Paketen zu laden.</p></li>
<li><p>Jetzte teste die App. Erscheint der Körper in der UI? Wenn das
funktioniert hat, ist dir vielleicht aufgefallen, dass die Graphik
keinen passenden Hintergrund hat. Das kannst du ändern, indem innerhalb
<code>renderPlot</code> <code>bg</code> auf <code>"transparent"</code>
setzt. Zudem könntest du innerhalb von <code>plotOutput</code> die Höhe
mit <code>height = 550px</code> etwas raufsetzen.</p></li>
<li><p>Als letzte Anpassung der UI setze innerhalb von
<code>plotOutput("körper")</code> das Argument <code>click</code> auf
<code>"körperclick"</code>. Damit registrieren wir den Input, den wir im
Server verwenden können, um die Körperteile zu identifizieren die
angeklickt wurden und um im Anschluss die Liste der angewählten
Körperteile zu ändern.</p></li>
<li><p>Kommen wir zum <code>server</code>. Als erstes gilt einmal wieder
einen <code>reactiveVal</code> zu kreieren. Tue dies irgendwo im
<code>server</code> und nenne ihn <code>körperteile</code>. Dieser
<code>reactiveVal</code> wird uns erlauben das Menge der ausgewählten
Körperteile als Funnktion der Klick-Inputs anzupassen.</p></li>
<li><p>Nun können wir uns daran machen die Klick-Mechanik zu bauen.
Beginnen wir mit einem <code>reactiveEvent</code>, sodass unsere
Klick-Mechanik nur dann läuft, wenn tatsächlich geklickt wurde. Setze
den richtigen Input ein.</p></li>
<li><p>Innerhalb des <code>observeEvent</code>s müssen wir uns zunächst
darum kümmern, dass wir identifizieren welches Körperteil angeklickt
wurde. Dies können wir mittels dem folgenden
<code>nearPoints</code>-Code erreichen. Die Funktion nimmt als erste
beiden Argumente den Datensatz aus dem wir Punkte auswhählen wollen,
hier der <code>körper</code> Datensatz, und den Klick-Input, hier der
<code>click</code> Input mit ID aus dem <code>imageOutput</code>. Als
nächstes muss bestimmt werden auf Basis welcher Variablen der nächste
Punkt bestimmt werden soll, hier die <code>"x"</code> und
<code>"y"</code> Koordinaten im <code>körper</code> Datensatz. Zuletzt
werden zwei Einstellungen vorgenommen, die dazu führen, dass Distanz des
Klicks zu den Punkten in <code>körper</code> aufgezeichnet wird und dass
die Identifikation der Punkte etwas liberaler ist. Das Ergebnis von
<code>nearPoints</code> ist ein Datensatz mit allen Punkten die
unterhalb der <code>threshold</code> liegen.</p></li>
<li><p>Im zweiten Schritt gilt es aus dem <code>points</code> Datensatz,
der eben kreiert wurde, dasjenige Körperteil zu identifizieren, dass am
ehesten das tatsächliche Ziel des Klicks war. Dies erledigt der unten
dargestellte Code-Block. Er identifiziert welches Körperteil die
niedrigste Distanz zum Klick im Sinne des ersten Dezils der Distanzen
(<code>quantile(dist_, .1)</code>) zwischen Punkten der jeweiligen
Polygone und dem Klick aufwies. Das in diesem Sinne nächste Körperteil
wird dann in <code>selected</code>.</p></li>
<li><p>Wir haben identifiziert, welches Körperteil wahrscheinlich
geklickt wurde. Jetzt geht es darum unseren <code>körperteile</code>
<code>reactiveValue</code> mit dieser Information anzupassen. Und zwar
soll <code>selected</code> zu den ausgewählten Körperteilen hinzugefügt
werden, wenn es noch nicht enthalten ist, und entfernt werden, wenn es
enthalten aktiviert ist. Das bedeutet wir brauchen wieder ein
<code>if</code>-<code>else</code>, das zunächst testet ob
<code>selected</code> in <code>körperteile</code> bereits enthalten ist
und dann entweder es hinzufügt oder es entfernt. Dieser erledigt der
neue Code-Block unten mit ein paar kleinen Anpassungen. Achte darauf
welche XX Klammern haben und welche nicht.</p></li>
<li><p>Jetzt gilt es sicherzustellen, dass sich änderne
<code>körperteile</code> <code>reactiveVal</code> auch an den richtigen
Stellen verwendet wird. Noch verwendet unser <code>server</code> Code
den alten <code>input$körperteile</code> innerhalb des
<code>daten</code> <code>reactive</code>. Tausche diese durch
<code>körperteile()</code> aus.</p></li>
<li><p>Das letzte was wir machen müssen bevor wir endlich einmal die App
testen können ist unseren Plot so anzupassen, dass angezeigt wird,
welche <code>körperteile</code> aktuell aktiv sind. Füge dafür dieses
<code>geom_polygon</code> nach dem ersten <code>geom_polygon</code> im
Körper plot ein. Du kannst sehen, dass dieses Polygon
<code>körperteile</code> verwendet um neue rote Polygone über die alten
zu zeichnen.</p></li>
<li><p>Teste jetzt einmal die App. Wenn die Körperteile, die du
anklickst rot werden und sich die Graphiken enstprechend ändern, bist du
ein wahrer Shiny Master. Es bleibt dann nur noch ein einziges kleines
Problem zu lösen. Der <code>zurücksetzen</code> Schalter ist noch nicht
in der Lage <code>körperteile</code> zurückzusetzen. Anstatt dem
obsolenten <code>updateInputSelect</code> im entsprechenden
<code>observeEvent</code> setze einfach <code>körperteile(c())</code>,
was alle Elemente aus <code>körperteile</code> entfernt und damit auch
den Körper und die anderen Plots anpasst.</p></li>
</ol>
</div>
<div id="lösung" class="section level2">
<h2>Lösung</h2>
<pre class="r"><code>library(shiny)
library(tidyverse)
library(tools)
library(shinyFeedback)
library(viridis)

ui = navbarPage(
  &quot;InjuryViewer&quot;,
  tabPanel(
    &quot;Dashboard&quot;,
    fluid = TRUE,
    icon = icon(&quot;chart-bar&quot;),
    
    sidebarLayout(
      sidebarPanel(
        width = 3,
        plotOutput(&quot;körper&quot;, height = 550, click = &quot;körper_click&quot;),
        sliderInput(&quot;alter&quot;, &quot;Alter&quot;, min = 0, max = 110, value = c(0, 110)),
        actionButton(&quot;diagnose_var&quot;, &quot;Diagnosen&quot;, width = &quot;32.5%&quot;),
        actionButton(&quot;unfallort_var&quot;, &quot;Unfallorte&quot;, width = &quot;32.5%&quot;),
        actionButton(&quot;gegenstand_var&quot;, &quot;Gegenstände&quot;, width = &quot;32.5%&quot;),
        actionButton(&quot;zurücksetzen&quot;, &quot;Zurücksetzen&quot;, width = &quot;100%&quot;)
      ),
      mainPanel(
        plotOutput(&quot;linien_plot&quot;),
        plotOutput(&quot;lollipop_plot&quot;)
      ),
    )
  ),
  
  tabPanel(
    &quot;Daten&quot;,
    fluid = TRUE,
    icon = icon(&quot;clipboard&quot;),
    tabsetPanel(
      tabPanel(
        title = &quot;Daten&quot;,
        h2(&quot;Aktuelle daten&quot;),
        dataTableOutput(&quot;daten&quot;)
        ),
      tabPanel(
        useShinyFeedback(),
        title = &quot;Upload&quot;,
        h2(&quot;Daten hochladen&quot;),
        h4(&quot;Achtung Daten werden überschrieben&quot;),
        br(),
        fileInput(
          inputId = &quot;hochladen&quot;,
          label = &quot;Wähle eine Datei aus&quot;,
          buttonLabel = &quot;Auswählen&quot;
        )
      ),
      tabPanel(
        title = &quot;Download&quot;,
        h2(&quot;Daten runterladen&quot;),
        br(),
        downloadButton(&quot;herunterladen&quot;,
                       &quot;Als .csv herunterladen&quot;,
                       style = &quot;font-size:20px&quot;)
      )
    )
  ),
  navbarMenu(
    &quot;Informationen&quot;,
    icon = icon(&quot;info-circle&quot;),
    tabPanel(&quot;Datensatz&quot;,
             fluidPage(fluidRow(
               column(
                 6,
                 HTML(&quot;&lt;h2&gt;National Electronic Injury Surveillance System (NEISS)&lt;/h2&gt;
                      &lt;h4&gt;Das National Electronic Injury Surveillance System (NEISS) Datenbank wird seit über 45 Jahren von der Consumer Product Safety Commission (CPSC) betrieben. Ihr Zweck ist die Sammlung von verletzungen, die im Zusammenhang von Konsumprodukten entstehen. Das CPSC nutzt die Daten um eine landesweite in Schätzung von produktabhängigen Verletzungen zu liefern.&lt;br&gt;&lt;br&gt;
                      NEISS basiert auf einer landesweit repräsentativen Stichprobe an Krankenhäusern in den Vereinigten Staaten und seinen Territorien. Jedes teilnehmende Krankenhaus berichtet Patienteninformationen für jeden Besuch einer Notfallabteilung. Mit den NEISS-Daten können landesweite Schätzungen von Besuchen in Notfallabteilungen von Krankenhäusern ermittelt werden.&lt;br&gt;&lt;br&gt;
                      Der aktuelle Datensatz ist ein Ausschnitt der NEISS-Daten. Die Daten wurden auf das Jahr 2017 begrenzt.&lt;br&gt;&lt;br&gt;
                      Mehr Informationen zu NEISS unter &lt;a&gt;https://www.cpsc.gov/Research--Statistics/NEISS-Injury-Data&lt;/a&gt;&lt;/h4&gt;&quot;
                   )
               )
             ))),
    tabPanel(&quot;About&quot;,
             fluidPage(fluidRow(
               column(6, HTML(&quot;&lt;h2&gt;The R Bootcamp&lt;/h2&gt;
                      &lt;h4&gt;Die App wurde erstellt von The R Bootcamp im Rahmen des Kurses Dashboards mit Shiny&lt;br&gt;&lt;br&gt;
                      Mehr Informationen zu The R Bootcamp unter &lt;a&gt;https://therbootcamp.github.io/&lt;/a&gt;&lt;/h4&gt;&quot;
                 ))
             ))),
  )
)

server &lt;- function(input, output, session) {
  
  verletzungen = reactiveVal(readRDS(&quot;daten/verletzungen.RDS&quot;))
  
  
  output$körper &lt;- renderPlot({
    körper %&gt;%
      ggplot(aes(x, y, group = id)) +
      geom_polygon() +
      geom_polygon(
        data = körper,
        aes(group = id),
        fill = viridis(5, option = &quot;G&quot;, end = .9)[5],
        col = &quot;white&quot;) +
        geom_polygon(
    data = körper %&gt;% filter(körperteil %in% körperteile()),
    aes(group = id),
    fill = &quot;red&quot;,
    col = &quot;white&quot;
  ) +
      labs(title = &quot;Verletzungen&quot;,
           subtitle = &quot;Klicke auf Körperteile&quot;) +
      theme_void() +
      theme(
        legend.position = &quot;none&quot;,
        plot.title = element_text( 
          hjust = .5, face = 2, size = 24),
         plot.subtitle = element_text(hjust = .5, size = 16)
        )
  }, bg = &quot;transparent&quot;)
  
  
  körperteile = reactiveVal()
  
  observeEvent(input$körper_click, {
    points = nearPoints(
      körper,
      input$körper_click,
      xvar = &quot;x&quot;,
      yvar = &quot;y&quot;,
      addDist = TRUE,
      threshold = 100
    )
    selected = points  %&gt;%
      group_by(körperteil, id) %&gt;%
      summarize(d = quantile(dist_, .1)) %&gt;%
      ungroup() %&gt;%
      arrange(d) %&gt;%
      slice(1) %&gt;%
      pull(körperteil)
    
    if (selected %in% körperteile()) {
      körperteile(körperteile()[körperteile() != selected])
    } else {
      körperteile(c(selected, körperteile()))
    }
  })
  
  
  daten = reactive({
  verletzungen() %&gt;%
    filter(körperteil %in% körperteile(),
           alter &gt;= input$alter[1],
           alter &lt;= input$alter[2])
  })
  
  output$daten = renderDataTable(verletzungen(),
                               options = list(pageLength = 10))
  
  output$linien_plot = renderPlot({
  
  daten() %&gt;% 
    count(alter, geschlecht, wt = anzahl) %&gt;%
    ggplot(aes(x = alter, y = n, col = geschlecht)) +
    geom_line(linewidth = 1.5) +
    theme_minimal() +
    theme(
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 16),
      legend.text = element_text(size = 12),
      legend.title = element_text(size = 16),
      plot.margin = margin(.5, .5, 1, 1, unit = &quot;cm&quot;),
      legend.position = &quot;top&quot;
    ) +
    scale_color_viridis_d(name = &quot;Geschlecht&quot;,
                          option = &quot;G&quot;,
                          end = .8) +
    labs(x = &quot;Alter&quot;,
         y = &quot;Geschätzte Anzahl Verletzungen&quot;)
          })
  
  lollipop_var = reactiveVal(&quot;diagnose&quot;)
  
  observeEvent(input$diagnose_var, {
    lollipop_var(&quot;diagnose&quot;)
  })
  observeEvent(input$unfallort_var, {
    lollipop_var(&quot;unfallort&quot;)
  })
  observeEvent(input$gegenstand_var, {
    lollipop_var(&quot;gegenstand&quot;)
  })
  
  output$lollipop_plot = renderPlot({
  
    daten() %&gt;%
      mutate(variable = .data[[lollipop_var()]]) %&gt;%
      count(variable, geschlecht, wt = anzahl) %&gt;%
      ggplot(aes(x = variable, y = n, col = geschlecht)) +
      geom_pointrange(
        aes(ymin = 0, ymax = n),
        linewidth = 1.2,
        size = 1.2,
        position = position_dodge(width = .5)
      ) +
      scale_color_viridis_d(option = &quot;G&quot;, end = .8) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = 16),
        axis.title.x = element_blank(),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(
          size = 16,
          angle = 45,
          hjust = 1
        ),
        plot.margin = margin(.5, .5, .5, 1, unit = &quot;cm&quot;),
        legend.position = &quot;none&quot;
      ) +
      labs(y = &quot;Geschätzte Anzahl&quot;)
    })
  
  
    observeEvent(input$hochladen, {
      endung &lt;- file_ext(input$hochladen$datapath)
      if(endung == &quot;RDS&quot;){
        verletzungen(readRDS(input$hochladen$datapath))
        } else {
        showFeedbackDanger(&quot;hochladen&quot;, &quot;Nur RDS Dateien können geladen werden!&quot;)
        Sys.sleep(3)
        }
          
      on.exit(hideFeedback(&quot;hochladen&quot;))
      })
  
    output$herunterladen &lt;- downloadHandler(
      filename = function() {&quot;verletzungen.csv&quot;},
      content = function(file) {write_tsv(verletzungen(), file)}
    )

    observeEvent(input$zurücksetzen, {
    
      körperteile(c()) 
      updateSliderInput(inputId = &quot;alter&quot;, value = c(0, 110))

    })
    
     
  }
  
  shinyApp(ui, server)</code></pre>
</div>
<div id="datensatz" class="section level2">
<h2>Datensatz</h2>
<p>Der Datensatz stammt von dem National Electronic Injury Surveillance
System (NEISS) in den USA, das seit vielen Jahren Unfälle aus einem
repräsentativen Stichprobe von Krankenhäusern sammelt. Der Datensatz
wurde ins Deutsche übersetzt und angepasst.<br />
Es liegen zwei Ausschnitte des Datensatzes vor.
<code>verletzungen.RDS</code> beinhaltet alle 251’545 Fälle des Jahres
2017, <code>verletzungen_jahresende.RDS</code> dagegen nur die 4’181
Fälle zwischen Heiligabend und Silvester.</p>
<p>Die beiden Datensätze beinhalten die folgenden Variablen:</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th align="left">Beschreibung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>datum</td>
<td align="left">Datum des Unfalls / der Verletzung</td>
</tr>
<tr class="even">
<td>alter</td>
<td align="left">Alter der Person</td>
</tr>
<tr class="odd">
<td>geschlecht</td>
<td align="left">Geschlecht der Person</td>
</tr>
<tr class="even">
<td>körperteil</td>
<td align="left">Körperteil, das verletzt wurde</td>
</tr>
<tr class="odd">
<td>diagnose</td>
<td align="left">Diagnose der Verletzung</td>
</tr>
<tr class="even">
<td>unfallort</td>
<td align="left">Unfallort der Verletzung</td>
</tr>
<tr class="odd">
<td>gegenstand</td>
<td align="left">Gegenstand, der die Verletzung herbeigeführt hat</td>
</tr>
<tr class="even">
<td>anzahl</td>
<td align="left">Anzahl an Verletzungen</td>
</tr>
</tbody>
</table>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
