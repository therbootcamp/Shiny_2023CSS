---
title: "Daten IO"
subtitle: ""
author: "<font style='font-style:normal'>Explorative Datenanalyse</font><br>
<a href='https://therbootcamp.github.io/Shiny_2023CSS/'><i class='fas fa-clock' style='font-size:.9em;' ></i></a>
<a href='https://therbootcamp.github.io'><i class='fas fa-home' style='font-size:.9em;'></i></a>
<a href='mailto:therbootcamp@gmail.com'><i class='fas fa-envelope' style='font-size: .9em;'></i></a>
<a href='https://www.linkedin.com/company/basel-r-bootcamp/'><i class='fab fa-linkedin' style='font-size: .9em;'></i></a>  
<a href='https://therbootcamp.github.io'><font style='font-style:normal'>The R Bootcamp @ CSS</font></a><br>  
<img src='https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/by-sa.png' style='height:15px;width:80px'/>"
output:
  html_document:
    css: practical.css
    self_contained: no
---

<p align="center" width="100%">
  <img src="image/signal.png" alt="Trulli" style="width:100%">
  <br>
  <font style="font-size:10px">from <a href="https://unsplash.com/photos/ouyjDk-KdfY">unsplash.com</a></font>
</p>

# {.tabset}

## Information

Dieses Practical besteht aus zwei Teilen. 

1. Aufgaben: Mit mehreren kleinen Apps wiederholst du zentrale Inhalte der Präsentation.  
2. App: Über die Sessions hinweg entwickelst Du die <a href="https://dirkwulff.shinyapps.io/TheRBootcamp/">InjuryViewer</a> App

Wie viel Zeit du in *Aufgaben* oder *App* verbringst ist dir überlassen. Wir empfehlen aber allen mit wenig Erfahrung mit Shiny erst einmal in Aufgaben zu schauen. Für die App stellen wir in einem eigenen Tab die Lösungen zur Verfügungen, so dass du in neue Themen einsteigen kannst ohne notwendigerweise alle Schritte der Appentwicklung abgeschlossen zu haben. 

Für jede App in Aufgaben erstelle bitte ein **neues Skript** und speichere es unter dem Namen der Abschnittsberschrift. Denk dran bei jedem neuen Skript `library(shiny)` an den Anfang zu setzen. Falls weitere Pakete nötig sind, werden sie in der jeweileigen Abschnitten erwähnt. 

Gerade am Anfang stellen wir Code-Templates zur verfügung in denen du allein die `XX` durch den richtigen Code bzw. die richtigen Objekte erstezen musst.   


## Aufgaben

### A - XXx


### B - XXx

### C - XXx


## App

1. Der nächste Schritt in der Entwicklung unserer App ist es das Einlesen und speichern der Daten zu ermöglichen. Kümmern wir uns zuerst um das Hochladen von Daten und fokussieren zunächst auf die UI. Ergänze ein `fileInput` im Upload Panels innerhalb des Daten NavBar Panels. Als `inputId`, `label`, und `buttonLabel` weise `"hochladen"`, `"Wähle eine Datei aus"`, und `"Auswählen` zu. Lasse die App einmal laufen und überprüfe ob der File upload zu sehen.  


```{r}

  tabPanel(
    title = "Upload",
    h2("Daten hochladen"),
    XX(XX, XX, XX)
    )

```

2. Im nächsten Schritt, verbessern wir ein klein bisschen die Usability. Erstens ergänzen wir eine Unterüberschrift, die uns warnt, dass wir unsere aktuellen Daten überschrieben, wenn wir neue Daten einlesen. Hierfür ergänze `h4("Achtung Daten werden überschrieben")` direkt unterhalb der Überschrift zweiter Ordnung. Zweitens, füge eine mit `br()` eine leere Zeile zwischen der Unterüberschrift und dem `fileInput` ein. 

```{r}

  tabPanel(
    title = "Upload",
    h2("Daten hochladen"),
    XX,
    XX,
    XX(XX, XX, XX)
    )

```

3. Die UI des Uploads ist fertig. Jetzt gilt es den `server` entsprechend anzupassen. Als erstes muss sichergestellt werden, dass die Daten nicht wie bisher ausserhalb des `sever`s gelesen werden sonder innerhalb. Zudem müssden die Daten genau wie das Objekt `daten` reaktiv werden, sodass sie sich ändern können sobald neue Daten hochgeladen werden. Es gibt verschiedene Wege, wie dies implementiert werden könnte. Machen wir es mit einem `reactiveVal`. Ziehe dafür `verletzungen <- readRDS(daten/verletzungen.RDS)` in den `sever` und setze eine `reactiveVal` um die Lesefunktion, so dass `verletzungen` reaktiver Wert ist, der als Default den gesamenten Datensatz beinhaltet.     


```{r}

verletzungen <- reactiveVal(XX)

```

4. Weil `verletzungen` jetzt ein reaktiver Wert ist, muss einer Stelle im `server` eine kleine Ändeurngen vorgenommen werden. Anonstent treten Probleme auf. Ahnst du schon wo? An einer Stelle im `server` wird `verletzungen` als normales Datenobjekt werden anstatt als eine reaktiver Wert, das heisst ohne Klammer anstatt mit. Ergänze die fehlenden Klammern und lasse die App einmal laufen. Wenn kein Fehler aufkommt, dann hast du alles richtig gemacht.

5. Da nun `verletzungen` ein reaktiver Wert ist, können wir Code schreiben der dazu führt, dass `verletzungen` sich ändert sobald eine neue Datei bereitgestellt wird. Hierzu eignet sich `observeEvent` Block. Ergänze einen solchen, der dann seinen Code laufen lässt wenn der Upload input (`input$hochladen`) sich ändert und innerhalb des Cdes `verletzungen` durch Einlesen der neuen Daten verändert. Verende dafür `input$hochladen$datapath`.    

```{r}

observeEvent(XX,{
  
  XX(readRDS(XX))
  
})

```

6. Teste nun die App. Wenn du alles richtig eingestellt hast, solltest du in der Lage sein alternative Daten einzulesen. Probiere einmal den kleineren Datensatz `verletzungen_jahresende.RDS`. Zuerst solltest du sehen, dass der Upload dir "Upload complete" rückmeldet. Dann solltest im Nachbartab Daten sehen, dass die Tabelle nur noch etwas mehr als viertausend Zeilen anstatt vorher mehreren hundertausend. Nichtsdesto sollte aber alles wie zuvor reibungslos funktionieren. Es sollte sogar möglich sein vor dem Upload Körperteile und Alter einzustellen und dass diese Einstellungen nach Upload immer noch aktiv sind und unmittelbar auf den neuen Datensatz angewendet werden. 

7. Der Uploadteil ist fertig. Kümmern wir uns jetzt um den Download. Ergänze in der UI unter dem Upload `tabPanel` einen `downloadButton` mit ID `"herunterladen"` und Label `"Als .csv herunterladen"`. Ergänze zudem `style = 'font-size:20px'`, um die Schrift etwas grösser zu machen, und ein `br()` vor dem `downloadButton` für etwas mehr Platz. 

```{r}

  tabPanel(
    title = "Upload",
    h2("Daten hochladen"),
    XX,
    XX(XX, XX, XX)
    )

```

8. Im `server` ergänze nun den `downloadHandler` wie unten dargestellt. Siehe, dass wir den Dateinamen 

```{r}

  output$herunterladen <- downloadHandler(
    filename = function() {"verletzungen.csv"},
    content = function(file) {write_tsv(verletzungen(), file)}
  )

```

9. Teste nun die App. Ist der Upload zu sehen und funktioniert er? Teste mal was passiert wenn du erst den kleinen  


## Lösung

```{r, echo = TRUE, eval = FALSE}

library(shiny)
library(tidyverse)
library(shinyWidgets)

ui = navbarPage(
  "InjuryViewer",
  
  tabPanel(
    "Dashboard",
    fluid = TRUE,
    icon = icon("chart-bar"),
    
    sidebarLayout(
      sidebarPanel(
        width = 3,
        selectInput("körperteil", "Körperteil", 
                    choices = unique(verletzungen$körperteil), 
                    multiple = TRUE),
        sliderInput("alter", "Alter", min = 0, max = 110, value = c(0, 110)),
        actionButton("diagnose_var", "Diagnosen"),
        actionButton("unfallort_var", "Unfallorte"),
        actionButton("gegenstand_var", "Gegenstände"),
      ),
      mainPanel(
        plotOutput("linien_plot"),
        plotOutput("lollipop_plot")
      ),
    )
  ),
  
  tabPanel(
    "Daten",
    fluid = TRUE,
    icon = icon("clipboard"),
    tabsetPanel(
      tabPanel(
        title = "Daten",
        h2("Aktuelle daten"),
        dataTableOutput("daten")
        ),
      tabPanel(
        title = "Upload",
        h2("Daten hochladen"),
        h4("Achtung Daten werden überschrieben"),
        br(),
        fileInput(
          inputId = "hochladen",
          label = "Wähle eine Datei aus",
          buttonLabel = "Auswählen"
        )
      ),
      tabPanel(
        title = "Download",
        h2("Daten runterladen"),
        br(),
        downloadButton("herunterladen",
                       "Als .csv herunterladen",
                       style = "font-size:20px")
      )
    )
  ),
  navbarMenu(
    "Informationen",
    icon = icon("info-circle"),
    tabPanel("Datensatz",
             fluidPage(fluidRow(
               column(
                 6,
                 HTML("<h2>National Electronic Injury Surveillance System (NEISS)</h2>
                      <h4>Das National Electronic Injury Surveillance System (NEISS) Datenbank wird seit über 45 Jahren von der Consumer Product Safety Commission (CPSC) betrieben. Ihr Zweck ist die Sammlung von verletzungen, die im Zusammenhang von Konsumprodukten entstehen. Das CPSC nutzt die Daten um eine landesweite in Schätzung von produktabhängigen Verletzungen zu liefern.<br><br>
                      NEISS basiert auf einer landesweit repräsentativen Stichprobe an Krankenhäusern in den Vereinigten Staaten und seinen Territorien. Jedes teilnehmende Krankenhaus berichtet Patienteninformationen für jeden Besuch einer Notfallabteilung. Mit den NEISS-Daten können landesweite Schätzungen von Besuchen in Notfallabteilungen von Krankenhäusern ermittelt werden.<br><br>
                      Der aktuelle Datensatz ist ein Ausschnitt der NEISS-Daten. Die Daten wurden auf das Jahr 2017 begrenzt.<br><br>
                      Mehr Informationen zu NEISS unter <a>https://www.cpsc.gov/Research--Statistics/NEISS-Injury-Data</a></h4>"
                   )
               )
             ))),
    tabPanel("About",
             fluidPage(fluidRow(
               column(6, HTML("<h2>The R Bootcamp</h2>
                      <h4>Die App wurde erstellt von The R Bootcamp im Rahmen des Kurses Dashboards mit Shiny<br><br>
                      Mehr Informationen zu The R Bootcamp unter <a>https://therbootcamp.github.io/</a></h4>"
                 ))
             ))),
  )
)

server <- function(input, output, session) {
  
  verletzungen = reactiveVal(readRDS("daten/verletzungen.RDS"))
  
  daten = reactive({
  verletzungen() %>%
    filter(körperteil %in% input$körperteil,
           alter >= input$alter[1],
           alter <= input$alter[2])
  })
  
  output$daten = renderDataTable(verletzungen(),
                               options = list(pageLength = 10))
  
  output$linien_plot = renderPlot({
  
  daten() %>% 
    count(alter, geschlecht, wt = anzahl) %>%
    ggplot(aes(x = alter, y = n, col = geschlecht)) +
    geom_line(linewidth = 1.5) +
    theme_minimal() +
    theme(
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 16),
      legend.text = element_text(size = 12),
      legend.title = element_text(size = 16),
      plot.margin = margin(.5, .5, 1, 1, unit = "cm"),
      legend.position = "top"
    ) +
    scale_color_viridis_d(name = "Geschlecht",
                          option = "G",
                          end = .8) +
    labs(x = "Alter",
         y = "Geschätzte Anzahl Verletzungen")
          })
  
  lollipop_var = reactiveVal("diagnose")
  
  observeEvent(input$diagnose_var, {
    lollipop_var("diagnose")
  })
  observeEvent(input$unfallort_var, {
    lollipop_var("unfallort")
  })
  observeEvent(input$gegenstand_var, {
    lollipop_var("gegenstand")
  })
  
  output$lollipop_plot = renderPlot({
  
    daten() %>%
      mutate(variable = .data[[lollipop_var()]]) %>%
      count(variable, geschlecht, wt = anzahl) %>%
      ggplot(aes(x = variable, y = n, col = geschlecht)) +
      geom_pointrange(
        aes(ymin = 0, ymax = n),
        linewidth = 1.2,
        size = 1.2,
        position = position_dodge(width = .5)
      ) +
      scale_color_viridis_d(option = "G", end = .8) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = 16),
        axis.title.x = element_blank(),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(
          size = 16,
          angle = 45,
          hjust = 1
        ),
        plot.margin = margin(.5, .5, .5, 1, unit = "cm"),
        legend.position = "none"
      ) +
      labs(y = "Geschätzte Anzahl")
    })
  
  
    observeEvent(input$hochladen, {
      verletzungen(readRDS(input$hochladen$datapath))
      })
  
    output$herunterladen <- downloadHandler(
      filename = function() {"verletzungen.csv"},
      content = function(file) {write_tsv(verletzungen(), file)}
    )

    
  }
  
  shinyApp(ui, server)

```


## Datensatz

Der Datensatz stammt von dem National Electronic Injury Surveillance System (NEISS) in den USA, das seit vielen Jahren Unfälle aus einem repräsentativen Stichprobe von Krankenhäusern sammelt. Der Datensatz wurde ins Deutsche übersetzt und angepasst.     
Es liegen zwei Ausschnitte des Datensatzes vor. `verletzungen.RDS` beinhaltet alle 251'545 Fälle des Jahres 2017, `verletzungen_jahresende.RDS` dagegen nur die 4'181 Fälle zwischen Heiligabend und Silvester. 

Die beiden Datensätze beinhalten die folgenden Variablen:

| Name   |      Beschreibung      |
|----------|:------------- |
| datum |  Datum des Unfalls / der Verletzung |
| alter |   Alter der Person   |
| geschlecht | Geschlecht der Person |
| körperteil | Körperteil, das verletzt wurde  |
| diagnose | Diagnose der Verletzung |
| unfallort | Unfallort der Verletzung |
| gegenstand | Gegenstand, der die Verletzung herbeigeführt hat |
| anzahl | Anzahl an Verletzungen |




